name: 'Comment PR'
description: |
  Post or update a PR comment with markdown content from a summary file.

  This action provides a reusable way to post PR comments with:
  - Automatic deduplication using comment markers
  - Branch and commit metadata
  - Truncation handling for large comments
  - Graceful error handling

  **Usage Example:**
  ```yaml
  - uses: ./.github/actions/comment-pr
    with:
      summary_file: scanner-summaries/opengrep.md
      comment_marker: opengrep-comment-marker
      title: 'üîç OpenGrep SAST Results'
  ```

inputs:
  summary_file:
    description: 'Path to markdown summary file to include in comment'
    required: true
  comment_marker:
    description: 'Unique HTML comment marker for deduplication (e.g., opengrep-comment-marker)'
    required: true
  title:
    description: 'Title for the PR comment (e.g., "üîç OpenGrep SAST Results")'
    required: true
  fallback_message:
    description: 'Message to show if summary file not found'
    required: false
    default: 'No results available'

runs:
  using: 'composite'
  steps:
    - name: Post PR comment
      uses: actions/github-script@v8
      continue-on-error: true
      env:
        SUMMARY_FILE: ${{ inputs.summary_file }}
        COMMENT_MARKER: ${{ inputs.comment_marker }}
        TITLE: ${{ inputs.title }}
        FALLBACK_MESSAGE: ${{ inputs.fallback_message }}
      with:
        script: |
          const fs = require('fs');

          try {
            const { SUMMARY_FILE, COMMENT_MARKER, TITLE, FALLBACK_MESSAGE } = process.env;

            let commentBody = `## ${TITLE}\n\n<!-- ${COMMENT_MARKER} -->\n\n`;

            // Add metadata
            const branchName = process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME;
            if (branchName) {
              commentBody += `**Branch:** \`${branchName}\`\n`;
            }
            const shortSha = context.sha.substring(0, 7);
            commentBody += `**Commit:** [\`${shortSha}\`](${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n\n`;

            // Add summary content
            if (fs.existsSync(SUMMARY_FILE)) {
              const content = fs.readFileSync(SUMMARY_FILE, 'utf8');
              commentBody += content;
            } else {
              commentBody += `**${FALLBACK_MESSAGE}**\n`;
            }

            commentBody += `\n---\n_Generated by [Argus](https://github.com/huntridge-labs/argus)_`;

            // Handle GitHub's 262KB comment limit
            const MAX_COMMENT_LENGTH = 262000;
            if (commentBody.length > MAX_COMMENT_LENGTH) {
              console.log(`Comment length (${commentBody.length}) exceeds limit, truncating...`);
              commentBody = commentBody.substring(0, MAX_COMMENT_LENGTH) + '\n\n... (truncated, see workflow artifacts for full results)';
            }

            // Check for existing comment to update
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const existingComment = comments.data.find(comment => {
              const hasMarker = comment.body.includes(COMMENT_MARKER);
              const isBot = comment.user.login === 'github-actions[bot]' || comment.user.type === 'Bot';
              return hasMarker && isBot;
            });

            if (existingComment) {
              console.log(`Updating existing comment (ID: ${existingComment.id})`);
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody
              });
            } else {
              console.log('Creating new comment');
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
            }

            console.log('Successfully posted/updated PR comment');
          } catch (error) {
            console.log('Failed to post PR comment:', error.message);
            if (error.status === 403) {
              console.log('Permission denied - may be running on a fork or missing pull-requests: write permission');
            } else if (error.status === 404) {
              console.log('Resource not found - check if PR exists');
            }
          }

branding:
  icon: 'message-square'
  color: 'blue'
